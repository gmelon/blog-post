>   초기의 지하철 노선도는 실제와 유사한 물리적인 지형 위에 구불구불한 운행 노선과 불규칙적인 역 간의 거리를 사실적으로 묘사하고 있었다. 문제는 이렇게 **사실적인 정보가 오히려** 지하철을 이용하는 승객들로 하여금 노선도를 **이해하기 어렵게 만들었다는 점**이다. (p.73)

>   해리 벡은 승객이 꼭 알아야 하는 사실만을 정확하게 표현하고 몰라도 되는 정보는 무시함으로써 이해하기 쉽고 단순하며 목적에 부합하는 지하철 노선도를 창조해 낼 수 있었다. (p.75)

## 추상화를 통한 복잡성 극복

*   진정한 의미에서 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 **사물의 놀라운 본질을 드러나게 하는 과정**
    *   불필요한 부분을 무시해 **현실에 존재하는 복잡성을 극복**하는게 추상화의 목적
*   훌륭한 추상화는 **목적에 부합**하는 것이어야 한다
    *   추상화의 수준, 이익, 가치는 목적에 의존적이다
*   모든 경우에 추상화의 목적은 **복잡성을 이해하기 쉬운 수준으로 단순화**하는 것

### 추상화의 두 가지 차원

1.   구체적 사물 간 공통점은 취하고 차이점을 버리는 일반화
2.   중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거

## 객체지향과 추상화

### 개념

*   공통점을 기반으로 객체들을 묶기 위한 그릇
    *   일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 뜻함
    *   전혀 다른 별개의 사물을 **공통점을 기반으로** 하나의 개념으로 묶음으로써 여러 사물을 개별적으로 다뤄야 하는 복잡한 상황을 피할 수 있다
*   개념을 사용하면 결과적으로 사물을 여러 그룹으로 **분류**할 수 있게 된다
    *   특정 그룹(개념)에 속하는 객체를 해당 개념의 **인스턴스(instance)** 라고 한다
    *   **개념을 통해 공통점을 가진 객체들을 분류할 수 있다**는 아이디어는 객체지향이 **복잡성을 극복하는 데 사용하는 가장 기본적인 인지 수단**

### 개념의 세 가지 관점

*   심볼(symbol) - 개념의 명칭
*   내연(intension) - 개념의 완전한 정의, 내연의 의를 통해 객체가 개념에 속하는지를 판단
*   외연(extension) - 개념에 속하는 모든 객체들의 집합

### 객체를 분류하기 위한 틀

*   분류 -> 객체에 특정한 개념을 적용하는 작업
    *   어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정함
    *   객체를 적절한 개념으로 분류해야 애플리케이션의 유지보수가 용이하고 변경에 유연한 대처가 가능
*   또한, 적절한 분류 체계는 개발자의 머릿속에 객체를 쉽게 찾고 조작할 수 있는 정신적인 지도를 제공한다

## 타입

*   **타입**의 정의는 **개념**의 정의와 완전히 동일함
    *   즉, 타입은 공통점을 기반으로 객체들을 묶기 위한 틀
    *   타입에 속하는 객체 역시 타입의 인스턴스라고 함

### 데이터 타입

*   타입 시스템의 목적은 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 **혼란을 방지**하는 것
    *   타입 시스템은 0과 1 (bit string)에 대해 **수행가능한 작업과 불가능한 작업을 구분**함으로써 데이터가 잘못 사용되는 것을 방지한다

#### 타입에 관련된 두 가지 중요한 사실

*   **어떤 데이터에 어떤 연산자를 적용할 수 있느냐**가 그 데이터의 타입을 결정한다
*   타입에 속한 데이터를 메모리에 **어떻게 표현하는지는 외부로부터 철저하게 감춰진다**

### 객체와 타입

*   객체를 타입에 따라 분류하고, 그 타입에 이름을 붙이는 것은 결국 새로운 데이터 타입을 선언하는 것과 같다
    *   하지만 **객체 != 데이터**이다
    *   객체의 상태는 행동으로 초래된 부수효과를 쉽게 표현하기 위해 도입된 개념일뿐임

#### 타입에 관련된 두 가지 사실은 객체에도 그대로 적용된다

*   어떤 행동을 수행하는지가 객체의 타입을 결정한다
*   객체의 내부 표현(상태)는 외부로부터 철저하게 감춰진다 (캡슐화)
    *   행동을 수행하는데 문제가 없다면, 상태는 어떤 표현이든 관계 없다
    *   데이터를 캡슐화하는 것은 객체를 행동에 따라 분류하기 위해 지켜야 할 가장 기본적인 원칙임

## 타입의 계층

### 일반화 / 특수화 관계

*   타입과 타입사이에는 일반화 / 특수화 관계가 존재할 수 있다
    *   일반화 -> 포괄적이라는 의미로, 더 넓은 범위를 나타낸다
    *   특수화 -> 더 좁은 범위의 객체를 포함, 집합의 관점에서 보면 일반화 개념의 부분집합
*   일반화 / 특수화 관계를 나타내는 것은 **상태를 표현하는 데이터가 아니라 행동** 이다.
    *   한 타입이 다른 타입보다 더 특수하게 / 일반적으로 행동해야 이 관계가 성립한다
    *   **더 일반적인 / 특수한 데이터(상태)를 가진다고 관계가 성립하는 것이 아니다!**

#### 특수한 / 일반적인 행동이란?

*   특수한 행동을 한다는 것은 일반화 타입이 할 수 있는 모든 행동을 동일하게 수행하면서 추가적인 행동을 갖는 것을 의미한다

### 슈퍼타입 / 서브타입

*   일반화 / 특수화 관계에서 
    *   좀 더 일반적인 타입을 슈퍼타입(supertype)
    *   좀 더 특수한 타입을 서브타입(subtype) 이라고 한다
*   이 관계는 **행동**에 의해 결정되고 서브타입은 슈퍼타입의 모든 행동을 수행할 수 있으므로 **서브타입은 슈퍼타입을 대체**할 수 있어야 한다.

### 일반화는 추상화를 위한 도구

*   서브타입에서만 제공하는 특수한 행동이 필요없을 때 서브타입을 슈퍼타입으로 일반화할 수 있다
    *   ex) 트럼프 인간을 단순히 **트럼프**라고 일반화해서 인식
*   이때, 1. 공통점을 그룹화하고 **2. 불필요한 특성을 제거**하는 **두 가지 추상화 기법이 동시에 적용**된다
    *   따라서 일반화를 사용해 추상화를 이루고 있다고 할 수 있다

## 정적 모델

### 타입의 목적

*   객체지향은 객체를 지향하지만 인간의 인지 능력으로는 **동적으로 변화는 객체의 복잡성**을 극복하기가 너무 어렵다
    *   때문에 **타입을 사용**한다!
*   타입은 시간에 따라 **동적으로 변하는 상태를 정적인 모습으로 다룰 수 있게** 해준다
    *   상태의 모든 경우의 수를 나열하는 대신, 해당 상태가 **변할 수 있다** 고만 인식함으로써 상황을 단순하게 만들 수 있다

### 타입 == 추상화

*   타입은 시간이라는 요소와 상태 변화라는 요소를 제거하고 정적인 관점에서 객체를 바라 볼 수 있게 해준다
    *   즉, 타입을 이용하면 객체의 **동적인 특성을 추상화**하고 **시간에 따른 상태 변경이라는 복잡성을 단순화**할 수 있다

### 동적 모델, 정적 모델

*   클래스를 작성하는 시점에는 시스템을 정적인 관점에서 접근, 애플리케이션이 실행될 땐 동적 모델이 동작
    *   두 모델을 적절히 혼용해야 좋은 객체지향 프로그램을 설계할 수 있다

#### 동적 모델 (스냅샷)

*   객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐

#### 정적 모델 (타입 모델)

*   객체가 가질 수 있는 모든 상태와 행동을 시간에 독립적으로 표현

### 클래스

*   객체지향 프로그래밍 언어에서 정적 모델은 **클래스**를 이용해 구현됨
*   클래스를 통해 **타입을 구현** 한다
    *   클래스 != 타입
    *   타입은 객체를 분류하기 위해 사용하는 **개념**이고, 클래스는 이를 **구현하는 매커니즘** 중 하나일 뿐
    *   클래스와 타입을 구분하는 것은 **설계를 유연하게 유지하기 위한 바탕**이 된다

---

이 게시글은 스터디에서 [ [객체지향의 사실과 오해 / 조영호](https://product.kyobobook.co.kr/detail/S000001628109) ] 책을 읽고 중요한 내용을 잊지 않기 위해 정리한 게시글입니다. 요약 및 생략된 내용이 많고 제가 이해한 대로 다시 정리한 내용이라 보다 자세하고 정확한 설명은 책 구매를 권장합니다.
