![](images/☕️_[자바_스터디]_12주차_n애노테이션.png)

## 어노테이션이란?
어노테이션은 사전적으로는 '주석' 이라는 의미이다. 자바에서 어노테이션은 클래스, 인터페이스, 메소드, 필드 등에 붙어서 컴파일러와 JVM에게 **추가적인 정보(metadata)**를 제공하는 역할을 한다.
### 어노테이션의 조상
어노테이션은 어떤 인터페이스를 상속받아 만들어질까? `javap` 명령을 통해 확인해보았다.
![](images/extends.png)

위 결과를 통해 어노테이션은 `java.lang.annotation.Annotation` 인터페이스를 상속받는 **특수한** 인터페이스임을 추측해볼 수 있다. 해당 조상 인터페이스에 별 메소드가 없는 것으로 봐서는 단순 어노테이션을 묶어놓기 위한 인터페이스가 아닐까..? 추측해봤다.

## 자바의 Built-in 어노테이션
### @Override
`@Override` 어노테이션은 해당 메소드가 부모 클래스의 메소드를 제대로 재정의하고 있음을 보장한다. 만약 `@Override`가 붙어있는 메소드인데 부모 클래스의 메소드를 재정의하고 있지 않다면 컴파일 오류가 발생한다. 메소드 재정의 시 `@Override` 어노테이션 작성은 필수는 아니지만, 오타나 시그니처를 잘못 입력하는 경우 등에 컴파일러의 도움을 받을 수 있으니 입력하는 것이 권장된다.

### @SuppressWarnings
이 어노테이션을 사용하면 컴파일러에 의해 발생한 **경고**가 보이지 않게 할 수 있다. 아래와 같이 `String[] value()` 가 필드로 생성되어 있으므로
```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```
아래 표의 값을 `value`에 입력하면 해당 경고가 표시되지 않도록 할 수 있다. value는 IDE나 JVM, 컴파일러 벤더에 따라 달라진다. ([기타 value 예시](https://www.ibm.com/docs/ko/radfws/9.6.1?topic=code-excluding-warnings))
| value 값 | 억제되는 경고 |
| :---: | :---: |
| all | 모든 경고 |
| cast | cast 오퍼레이션과 관련된 경고 |
| deprecation | @Deprecated된 대상에서 발생하는 경고 |
| unchecked | 미확인 연산과 관련된 경고 |
| rawtypes | 제네릭 타입을 명시하지 않을 때 발생하는 경고 |

예를 들어 아래와 같이 `ArrayList`를 제네릭 명시 없이 사용하면 경고가 발생하는데,
![](images/suppresswarning_1.png)

`@SuppressWarning("rawtypes")` 를 통해 해당 경고가 표시되지 않도록 할 수 있다.
![](images/suppresswarning_2.png)

### @Deprecated
deprecated될 메소드에 붙여준다. 이 어노테이션이 붙은 메소드를 사용하면 컴파일 시 곧 지원이 만료될 메서드를 사용하고 있다는 경고 메시지가 출력된다. 이렇게 함으로써 API를 사용하는 클라이언트 개발자에게 해당 메소드가 곧 deprecated될 것이므로 다른 메서드를 사용하라는 정보를 전달할 수 있다.

### @FunctionalInterface
함수형 인터페이스를 명시할 떄 사용한다. 이 어노테이션이 붙은 인터페이스는 오직 하나의 추상 메소드만 가질 수 있도록 컴파일러가 강제해준다. (추상 메소드가 아닌 메소드는 가능)
![](images/functional_interface_1.png)
`@FunctionalInterface`가 없으면 여러 추상 메서드가 가능하지만, 아래와 같이 붙여주면 컴파일러 레벨에서 오류를 발생시켜준다.
![](images/functional_interface_2.png)

## 애노테이션 정의하는 방법
`@interface` 를 사용해 아래와 같이 정의할 수 있다.
```java
public @interface MyAnnotation {
}
```
어노테이션은 추상 메소드들을 가질 수 있고, 해당 메소드들은 아래와 같은 규칙을 따라야 한다.
1. 메소드는 예외를 던질 수 없다
2. 메소드는 파라미터를 가질 수 없다
3. 메소드는 `원시타입`, `String`, `Class`, `enum`, `이들의 배열` 중 하나를 반환해야 한다
4. 메소드들은 `default` 값을 가질 수 있다.

추상 메서드의 개수에 따라 어노테이션은 아래 3가지로 나뉜다.
1. Marker Annotaion
2. Single-Value Annotation
3. Multi-Value Annotation

### Marker Annotation
추상 메소드가 없는 어노테이션을 말한다. `@Override`나 `@Deprecated`가 여기에 속한다. 단지 컴파일러에게 **어떤 정보를 전달**하기 위해서 존재하기 때문에 이런 이름이 붙여진 것 같다.
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```
### Single-Value Annotation
하나의 메서드를 갖는 어노테이션을 말한다. 아래와 같이 선언하고 사용할 수 있다.
```java
public @interface MyAnnotation {
    int value();
}

---

@MyAnnotation(value = 0)
...

@MyAnnotation(value = 10)
...

// 필수로 입력해야 하는 값이 하나만 존재하는 경우 메서드 이름 생략 가능
@MyAnnotation(10)
...
```

`default` 값을 제공할 수도 있다. `default`가 제공되는 값의 경우 아래와 같이 입력을 생략할 수도 있다.
```java
public @interface MyAnnotation {
    int value() default 0;
}

---

@MyAnnotation() // 값을 생략해도 value = 0과 같음
...

// 기존과 동일하게도 사용 가능
@MyAnnotation(value = 10)
...

@MyAnnotation(10)
...
```

배열을 반환하는 메서드의 경우 `{ }`를 사용해 여러 개의 값을 전달할 수 있다.
```java
public @interface MyAnnotation {
    int[] value() default {1, 2, 3};
}

---

@MyAnnotation()
...

@MyAnnotation(value = {4, 5, 6})
...
```
### Multi-Value Annotation
두 개 이상의 메서드를 갖는 어노테이션을 말한다.
```java
public @interface MyAnnotation {
    int value();
    String name();
    String option() default "OPT";
}

---

// 아래와 같이 , 로 구분해 입력할 수 있다.
// default 값이 있는 메소드는 마찬가지로 입력을 생략할 수 있다.
@MyAnnotation(value = 10, name = "HSH")
```

## meta-annotation
다른 어노테이션에 사용되는 어노테이션을 말한다. `@Target`이 `ANNOTATION-TYPE`으로 지정되어 있다. 대표적으로 `@Retention`, `@Target`, `@Documented` 등이 있다.
### @retention
어노테이션이 활성화(유지)되는 레벨을 지정하기 위해 사용한다. 아래의 3가지 타입이 존재한다.
| RetentionPolicy | 활성화 범위 |
| :---: | :---: |
| SOURCE | 소스코드에서만 사용되고 컴파일 시점에 컴파일러에 의해 삭제된다. 따라서 컴파일된 `.class` 파일에선 확인할 수 없다 |
| CLASS (기본값) | `.class` 파일에서 확인 가능하다. 컴파일러에겐 영향을 주지만 JVM에는 영향을 주지 못한다 |
| RUNTIME | 런타임에 까지 영향을 준다. 즉, 컴파일러와 JVM 모두에 영향을 준다 |

`SOURCE`로 사용되면 일반 주석처럼 사용되는 의미이다. 즉, 컴파일될 때는 해당 어노테이션의 정보가 필요없어진다는 뜻이다. `@Override`가 대표적 예시이다.
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```

`RUNTIME`으로 지정된 어노테이션은 리플렉션에 의해 활용될 수 있다고 한다. 이 부분은 리플렉션에 대해 정리할 때 같이 공부해봐야겠다.

### @target
어노테이션이 적용될 타겟의 타입을 명시하기 위해 사용한다. `java.lang.annotation.ElementType`에 정의된 아래와 같은 상수를 사용해 어노테이션의 타겟을 명시할 수 있다. 만약 `@Target`을 명시하지 않으면 자바의 모든 element에서 해당 어노테이션을 사용할 수 있다.
| ElementType | 어노테이션 타겟 |
| :---: | :---: |
| TYPE | 클래스, 인터페이스(어노테이션 포함), enum |
| FIELD | 필드 |
| METHOD | 메서드 |
| CONSTRUCTOR | 생성자 |
| LOCAL_VARIABLE | 로컬 변수 |
| ANNOTATION_TYPE | 에노테이션 |
| PARAMETER | 파라미터 |

아래와 같이 사용할 수 있다.
```java
// 메소드에만 사용 가능
@Target(ElementType.METHOD)
public @interface MyAnnotation {
}
```
![](images/target_1.png)
(enum에 붙일 경우 컴파일 오류 발생)

아래와 같이 여러 타겟을 지정할 수도 있다.
```java
@Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface MyAnnotation {
}
```

`@Target` 어노테이션의 경우 어노테이션을 타겟으로 하므로 아래와 같이 `@Target(ElementType.ANNOTATION_TYPE)` 이 붙어있다.
```java
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    ElementType[] value();
}
```

### @Inherited
기본적으로 어노테이션은 자식 클래스에게 상속되지 않는다. 하지만 `@Inherited` 어노테이션이 적용된 어노테이션이 부모 클래스에 적용되었다면 자식 클래스에게 해당 어노테이션이 전파된다.

### @documented
기본적으로는 `Javadoc`을 사용했을 때 적용된 어노테이션 정보는 출력되지 않는다. 다만, `@Documented` 어노테이션이 적용된 어노테이션은 `Javadoc`에서 기본적으로 어노테이션 정보를 출력해준다.

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MyAnnotation {
}

---

@MyAnnotation
public class Parent {}
```
![](images/documented_1.png)

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
// @Documented
public @interface MyAnnotation {
}

---

@MyAnnotation
public class Parent {}
```
![](images/documented_2.png)


## 애노테이션 프로세서
어노테이션 프로세서는 어노테이션을 기반으로 컴파일 시점에 추가적인 파일 / 코드를 생성하는 기술을 말한다. 생성되는 파일은 자바 파일에 한정되지 않아서 자바 코드의 어노테이션을 기반으로 description, metadata, documentation, resources를 포함한 기타 모든 종류의 파일을 생성할 수 있다.

예시로는 QueryDSL, JPA에서 메타 클래스를 생성하는데에 사용되고 Lombok에서 추가적인 코드를 생성하는데 사용된다.

간단한 작동 방식으로는, 먼저 컴파일러가 소스 코드에서 어노테이션을 탐색하고 각 어노테이션에 맞는 어노테이션 프로세스를 선택한다. 그리고 이렇게 선택된 어노테이션 프로세서들은 추가적인 파일 / 코드를 생성한다.

자주 사용되는 Lombok을 예시로 가져와봤다.
```java
import lombok.Data;

@Data
public class Person {
    private final int age;
    private final String name;
    private final String[] group;
}
```

위와 같이 `@Data` 라는 롬복에서 제공하는 어노테이션을 붙여주고, 인텔리제이에서 어노테이션 프로세서 설정을 켜준다. 해당 클래스를 컴파일한 결과는 아래와 같다.

```java
public class Person {
    private final int age;
    private final String name;
    private final String[] group;

    public Person(final int age, final String name, final String[] group) {
        this.age = age;
        this.name = name;
        this.group = group;
    }

    public int getAge() {
        return this.age;
    }

    public String getName() {
        return this.name;
    }

    public String[] getGroup() {
        return this.group;
    }

    public boolean equals(final Object o) {
        if (o == this) {
            return true;
        } else if (!(o instanceof Person)) {
            return false;
        } else {
            Person other = (Person)o;
            if (!other.canEqual(this)) {
                return false;
            } else if (this.getAge() != other.getAge()) {
                return false;
            } else {
                Object this$name = this.getName();
                Object other$name = other.getName();
                if (this$name == null) {
                    if (other$name == null) {
                        return Arrays.deepEquals(this.getGroup(), other.getGroup());
                    }
                } else if (this$name.equals(other$name)) {
                    return Arrays.deepEquals(this.getGroup(), other.getGroup());
                }

                return false;
            }
        }
    }

    protected boolean canEqual(final Object other) {
        return other instanceof Person;
    }

    public int hashCode() {
        int PRIME = true;
        int result = 1;
        result = result * 59 + this.getAge();
        Object $name = this.getName();
        result = result * 59 + ($name == null ? 43 : $name.hashCode());
        result = result * 59 + Arrays.deepHashCode(this.getGroup());
        return result;
    }

    public String toString() {
        int var10000 = this.getAge();
        return "Person(age=" + var10000 + ", name=" + this.getName() + ", group=" + Arrays.deepToString(this.getGroup()) + ")";
    }
}
```

`final` 필드들을 인자로 받는 생성자, 각 필드의 getter와 setter, equals()와 hashCode() 메서드 등등이 컴파일 단계에서 자동으로 생성되었다. `@Data` 라는 어노테이션을 기반으로 롬복의 어노테이션 프로세서가 동작한 결과이다.

## 질문
1. `@Override`를 붙였을 때 메서드가 재정의되어있지 않으면 오류가 발생하는 것은 자바 코드가 아니라 컴파일러 레벨에서 명세된 기능인가?
   1. 어노테이션 프로세서..?

## 참고자료
* https://www.javatpoint.com/java-annotation
* https://b-programmer.tistory.com/264
* https://www.baeldung.com/java-annotation-processing-builder